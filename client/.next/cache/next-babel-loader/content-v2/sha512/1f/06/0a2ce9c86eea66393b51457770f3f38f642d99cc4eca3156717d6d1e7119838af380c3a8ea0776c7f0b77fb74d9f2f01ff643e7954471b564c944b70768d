{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* eslint-disable import/no-anonymous-default-export */\nimport NextAuth from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport pino from \"pino\";\nimport { GraphQLClient, gql } from \"graphql-request\";\nimport ramda from \"ramda\";\nconst ACCESS_TOKEN_URL = `${process.env.NEXTAUTH_CREDENTIAL_AUTHORIZATION_URL}connect/token?lang=fa-ir`;\nconst REVOKE_ACCESS_TOKEN_URL = `${process.env.NEXTAUTH_CREDENTIAL_AUTHORIZATION_URL}tokens/cancel`;\nconst REVOKE_REFRESH_TOKEN_URL = `${process.env.NEXTAUTH_CREDENTIAL_AUTHORIZATION_URL}connect/revocation`;\nconst CLIENT_ID = process.env.NEXTAUTH_CREDENTIAL_CLIENT_ID;\nconst CLIENT_SECRET = process.env.NEXTAUTH_CREDENTIAL_CLIENT_SECRET;\nconst logger = pino({\n  name: \"NEXT_AUTH\",\n  prettyPrint: {\n    translateTime: \"SYS:standard\",\n    ignore: \"pid,hostname,time\"\n  }\n});\nconst options = {\n  providers: [Providers.Credentials({\n    id: \"SIGN_IN\",\n    name: \"Just a click\",\n    credentials: {\n      username: {\n        label: \"Username\",\n        type: \"text\"\n      },\n      password: {\n        label: \"Password\",\n        type: \"password\"\n      },\n      slug: {\n        label: \"Slug\",\n        type: \"hidden\"\n      }\n    },\n\n    async authorize(credentials) {\n      logger.info(credentials, \"[CREDENTIALS]\");\n      const {\n        username,\n        password\n      } = credentials;\n      const response = await fetch(ACCESS_TOKEN_URL, {\n        body: new URLSearchParams({\n          client_id: CLIENT_ID,\n          grant_type: \"password\",\n          client_secret: CLIENT_SECRET,\n          username,\n          password\n        }),\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        method: \"POST\"\n      });\n      const tokens = await response.json();\n\n      if (!response.ok && tokens.error) {\n        logger.error(tokens, \"[FETCH][RESPONSE][ERROR]\");\n        return Promise.reject(new Error(tokens.error_description));\n      }\n\n      logger.info(tokens, \"[FETCH][RESPONSE]\");\n      return tokens;\n    }\n\n  }), Providers.Credentials({\n    id: \"SIGN_UP\",\n    name: \"SignUp\",\n    credentials: {\n      username: {\n        label: \"Username\",\n        type: \"text\"\n      },\n      password: {\n        label: \"Password\",\n        type: \"password\"\n      } // slug: { label: 'Slug', type: 'hidden' },\n\n    },\n\n    async authorize(credentials) {\n      logger.info(credentials, \"[SIGN_UP][CREDENTIALS]\");\n      const {\n        username,\n        password\n      } = credentials;\n      const SIGN_UP_MUTATION = gql`\n          mutation($username: String!, $password: String!) {\n            register(\n              registerReqDto: {\n                dto: { userName: $username, password: $password }\n              }\n            ) {\n              isSuccess\n              listDto {\n                items {\n                  access_token\n                  expires_in\n                  refresh_token\n                  token_type\n                  scope\n                  fullname\n                }\n              }\n            }\n          }\n        `;\n      const client = new GraphQLClient(process.env.NEXT_PUBLIC_CREDENTIAL_IDENTITYRESOURCE_URL);\n      const response = await client.request(SIGN_UP_MUTATION, {\n        username,\n        password\n      }).then(ramda.path([\"register\", \"listDto\", \"items\", 0])).catch(err => {\n        logger.error(err, \"[SIGN_UP][RESPONSE]\");\n        return Promise.reject(new Error(err.message));\n      });\n      console.log(\"ðŸš€ >> file: [...nextauth].ts >> line 124 >> authorize >> response\", response);\n      logger.info(response, \"[SIGN_UP][RESPONSE]\");\n      return response;\n    }\n\n  })],\n  session: {\n    // Use JSON Web Tokens for session instead of database sessions.\n    // This option can be used with or without a database for users/accounts.\n    // Note: `jwt` is automatically set to `true` if no database is specified.\n    jwt: true // Seconds - How long until an idle session expires and is no longer valid.\n    // maxAge: 30 * 24 * 60 * 60, // 30 days\n    // Seconds - Throttle how frequently to write to database to extend a session.\n    // Use it to limit write operations. Set to 0 to always update the database.\n    // Note: This option is ignored if using JSON Web Tokens\n    // updateAge: 24 * 60 * 60, // 24 hours\n\n  },\n  // JSON Web tokens are only used for sessions if the `jwt: true` session\n  // option is set - or by default if no database is specified.\n  // https://next-auth.js.org/configuration/options#jwt\n  jwt: {\n    // A secret to use for key generation (you should set this explicitly)\n    secret: process.env.NEXTAUTH_JWT_SECRET // secret: 'INp8IvdIyeMcoGAgFGoA61DdBglwwSqnXJZkgz8PSnw',\n    // Set to true to use encryption (default: false)\n    // encryption: true,\n    // You can define your own encode/decode functions for signing and encryption\n    // if you want to override the default behaviour.\n    // encode: async ({ secret, token, maxAge }) => {},\n    // decode: async ({ secret, token, maxAge }) => {},\n\n  },\n  callbacks: {\n    async signIn(user, account, profile) {\n      logger.info({\n        user,\n        account,\n        profile\n      }, \"[signIn]\");\n      return true;\n    },\n\n    async jwt(prevToken, account, profile) {\n      logger.info({\n        prevToken,\n        account,\n        profile\n      }, \"[JWT_CALLBACK]\"); // Signing in\n\n      if (account && profile && profile.type === \"credentials\") {\n        return {\n          access_token: account.access_token,\n          refresh_token: account.refresh_token,\n          token_type: account.token_type,\n          fullname: account.fullname,\n          expires_in: Date.now() + account.expires_in * 1000\n        };\n      } // TODO: try to refresh token 1 minute before expired time\n      // Subsequent use of JWT, the user has been logged in before\n      // access token has not expired yet\n\n\n      if (Date.now() < prevToken.expires_in) {\n        return prevToken;\n      } // access token has expired, try to update\n\n\n      return refreshAccessToken(prevToken);\n    },\n\n    //@ts-ignore can't find exact type problem\n    async session(session, token) {\n      logger.info({\n        session,\n        token\n      }, \"[SESSION_CALLBACK]\");\n\n      if (token) {\n        session.user = {\n          name: token.fullname\n        };\n        session.accessToken = token.access_token; // session.expires = token.expires_in // WATCH !!\n      }\n\n      return session;\n    }\n\n  },\n  pages: {},\n  events: {\n    async signOut(message) {\n      await revokeJWTTokens(message);\n      logger.info(message, \"[EVENT][SIGN_OUT]\");\n    },\n\n    async session(message) {\n      logger.info(message, \"[EVENT][SESSION]\");\n    }\n\n  },\n  debug: true,\n  logger: {\n    error(code, ...message) {\n      logger.error(code, message);\n    },\n\n    warn(code, ...message) {\n      logger.warn(code, message);\n    },\n\n    debug(code, ...message) {\n      logger.debug(code, message);\n    }\n\n  }\n}; // For more information on each option (and a full list of options) go to\n// https://next-auth.js.org/configuration/options\n\nasync function refreshAccessToken(prevToken) {\n  try {\n    logger.warn(prevToken, \"[REFRESH_TOKEN][PREV]\");\n    const response = await fetch(ACCESS_TOKEN_URL, {\n      body: new URLSearchParams({\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        grant_type: \"refresh_token\",\n        scope: \"offline_access openid profile\",\n        //TODO:it sould replace with env variable\n        refresh_token: prevToken.refresh_token\n      }),\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      method: \"POST\"\n    });\n    const responseData = await response.json();\n\n    if (!response.ok) {\n      throw responseData;\n    }\n\n    const _ref = responseData,\n          {\n      id_token\n    } = _ref,\n          rest = _objectWithoutProperties(_ref, [\"id_token\"]);\n\n    const newToken = _objectSpread(_objectSpread({}, rest), {}, {\n      fullname: prevToken.fullname,\n      expires_in: Date.now() + responseData.expires_in * 1000\n    });\n\n    logger.warn(newToken, \"[REFRESH_TOKEN][NEW]\");\n    return newToken;\n  } catch (error) {\n    logger.error(error, \"[REFRESH_TOKEN]\");\n    return prevToken;\n  }\n}\n\nasync function revokeJWTTokens(token) {\n  try {\n    await fetch(REVOKE_ACCESS_TOKEN_URL, {\n      headers: {\n        Authorization: token.access_token\n      },\n      method: \"POST\"\n    }).catch(error => {\n      throw new Error(error);\n    });\n    await fetch(REVOKE_REFRESH_TOKEN_URL, {\n      body: new URLSearchParams({\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        token_type_hint: \"refresh_token\",\n        token: token.refresh_token\n      }),\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      method: \"POST\"\n    }).catch(error => {\n      throw new Error(error);\n    });\n  } catch (error) {\n    logger.error(error, \"[REVOKE_TOKEN]\");\n  }\n}\n\nexport default ((req, res) => NextAuth(req, res, options));","map":{"version":3,"sources":["/home/mohammad/projects/dorreh/market multi/client/src/pages/api/auth/[...nextauth].ts"],"names":["NextAuth","Providers","pino","GraphQLClient","gql","ramda","ACCESS_TOKEN_URL","process","env","NEXTAUTH_CREDENTIAL_AUTHORIZATION_URL","REVOKE_ACCESS_TOKEN_URL","REVOKE_REFRESH_TOKEN_URL","CLIENT_ID","NEXTAUTH_CREDENTIAL_CLIENT_ID","CLIENT_SECRET","NEXTAUTH_CREDENTIAL_CLIENT_SECRET","logger","name","prettyPrint","translateTime","ignore","options","providers","Credentials","id","credentials","username","label","type","password","slug","authorize","info","response","fetch","body","URLSearchParams","client_id","grant_type","client_secret","headers","method","tokens","json","ok","error","Promise","reject","Error","error_description","SIGN_UP_MUTATION","client","NEXT_PUBLIC_CREDENTIAL_IDENTITYRESOURCE_URL","request","then","path","catch","err","message","console","log","session","jwt","secret","NEXTAUTH_JWT_SECRET","callbacks","signIn","user","account","profile","prevToken","access_token","refresh_token","token_type","fullname","expires_in","Date","now","refreshAccessToken","token","accessToken","pages","events","signOut","revokeJWTTokens","debug","code","warn","scope","responseData","id_token","rest","newToken","Authorization","token_type_hint","req","res"],"mappings":"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","sourcesContent":["/* eslint-disable import/no-anonymous-default-export */\nimport type { NextApiRequest, NextApiResponse } from \"next\";\nimport NextAuth, { NextAuthOptions } from \"next-auth\";\nimport Providers from \"next-auth/providers\";\nimport pino from \"pino\";\nimport { GraphQLClient, gql } from \"graphql-request\";\nimport ramda from \"ramda\";\n\nconst ACCESS_TOKEN_URL = `${process.env.NEXTAUTH_CREDENTIAL_AUTHORIZATION_URL}connect/token?lang=fa-ir`;\nconst REVOKE_ACCESS_TOKEN_URL = `${process.env.NEXTAUTH_CREDENTIAL_AUTHORIZATION_URL}tokens/cancel`;\nconst REVOKE_REFRESH_TOKEN_URL = `${process.env.NEXTAUTH_CREDENTIAL_AUTHORIZATION_URL}connect/revocation`;\nconst CLIENT_ID = process.env.NEXTAUTH_CREDENTIAL_CLIENT_ID;\nconst CLIENT_SECRET = process.env.NEXTAUTH_CREDENTIAL_CLIENT_SECRET;\n\nconst logger = pino({\n  name: \"NEXT_AUTH\",\n  prettyPrint: {\n    translateTime: \"SYS:standard\",\n    ignore: \"pid,hostname,time\",\n  },\n});\n\ninterface JWT_Token {\n  id_token?: string;\n  access_token: string;\n  expires_in: number;\n  token_type: string;\n  refresh_token: string;\n  scope: string;\n  fullname: string;\n}\n\nconst options: NextAuthOptions = {\n  providers: [\n    Providers.Credentials({\n      id: \"SIGN_IN\",\n      name: \"Just a click\",\n      credentials: {\n        username: { label: \"Username\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" },\n        slug: { label: \"Slug\", type: \"hidden\" },\n      },\n      async authorize(credentials) {\n        logger.info(credentials, \"[CREDENTIALS]\");\n        const { username, password } = credentials;\n\n        const response = await fetch(ACCESS_TOKEN_URL, {\n          body: new URLSearchParams({\n            client_id: CLIENT_ID,\n            grant_type: \"password\",\n            client_secret: CLIENT_SECRET,\n            username,\n            password,\n          }),\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          method: \"POST\",\n        });\n\n        const tokens = await response.json();\n\n        if (!response.ok && tokens.error) {\n          logger.error(tokens, \"[FETCH][RESPONSE][ERROR]\");\n\n          return Promise.reject(new Error(tokens.error_description));\n        }\n\n        logger.info(tokens, \"[FETCH][RESPONSE]\");\n\n        return tokens;\n      },\n    }),\n    Providers.Credentials({\n      id: \"SIGN_UP\",\n      name: \"SignUp\",\n      credentials: {\n        username: { label: \"Username\", type: \"text\" },\n        password: { label: \"Password\", type: \"password\" },\n        // slug: { label: 'Slug', type: 'hidden' },\n      },\n      async authorize(credentials) {\n        logger.info(credentials, \"[SIGN_UP][CREDENTIALS]\");\n        const { username, password } = credentials;\n\n        const SIGN_UP_MUTATION = gql`\n          mutation($username: String!, $password: String!) {\n            register(\n              registerReqDto: {\n                dto: { userName: $username, password: $password }\n              }\n            ) {\n              isSuccess\n              listDto {\n                items {\n                  access_token\n                  expires_in\n                  refresh_token\n                  token_type\n                  scope\n                  fullname\n                }\n              }\n            }\n          }\n        `;\n\n        const client = new GraphQLClient(\n          process.env.NEXT_PUBLIC_CREDENTIAL_IDENTITYRESOURCE_URL\n        );\n        const response = await client\n          .request(SIGN_UP_MUTATION, { username, password })\n          .then(ramda.path([\"register\", \"listDto\", \"items\", 0]))\n          .catch((err) => {\n            logger.error(err, \"[SIGN_UP][RESPONSE]\");\n            return Promise.reject(new Error(err.message));\n          });\n        console.log(\n          \"ðŸš€ >> file: [...nextauth].ts >> line 124 >> authorize >> response\",\n          response\n        );\n\n        logger.info(response, \"[SIGN_UP][RESPONSE]\");\n\n        return response;\n      },\n    }),\n  ],\n\n  session: {\n    // Use JSON Web Tokens for session instead of database sessions.\n    // This option can be used with or without a database for users/accounts.\n    // Note: `jwt` is automatically set to `true` if no database is specified.\n    jwt: true,\n\n    // Seconds - How long until an idle session expires and is no longer valid.\n    // maxAge: 30 * 24 * 60 * 60, // 30 days\n\n    // Seconds - Throttle how frequently to write to database to extend a session.\n    // Use it to limit write operations. Set to 0 to always update the database.\n    // Note: This option is ignored if using JSON Web Tokens\n    // updateAge: 24 * 60 * 60, // 24 hours\n  },\n\n  // JSON Web tokens are only used for sessions if the `jwt: true` session\n  // option is set - or by default if no database is specified.\n  // https://next-auth.js.org/configuration/options#jwt\n  jwt: {\n    // A secret to use for key generation (you should set this explicitly)\n    secret: process.env.NEXTAUTH_JWT_SECRET,\n    // secret: 'INp8IvdIyeMcoGAgFGoA61DdBglwwSqnXJZkgz8PSnw',\n    // Set to true to use encryption (default: false)\n    // encryption: true,\n    // You can define your own encode/decode functions for signing and encryption\n    // if you want to override the default behaviour.\n    // encode: async ({ secret, token, maxAge }) => {},\n    // decode: async ({ secret, token, maxAge }) => {},\n  },\n\n  callbacks: {\n    async signIn(user, account, profile) {\n      logger.info({ user, account, profile }, \"[signIn]\");\n\n      return true;\n    },\n    async jwt(prevToken, account: Record<string, any>, profile) {\n      logger.info({ prevToken, account, profile }, \"[JWT_CALLBACK]\");\n\n      // Signing in\n      if (account && profile && profile.type === \"credentials\") {\n        return {\n          access_token: account.access_token,\n          refresh_token: account.refresh_token,\n          token_type: account.token_type,\n          fullname: account.fullname,\n          expires_in: Date.now() + account.expires_in * 1000,\n        };\n      }\n\n      // TODO: try to refresh token 1 minute before expired time\n      // Subsequent use of JWT, the user has been logged in before\n      // access token has not expired yet\n      if (Date.now() < prevToken.expires_in) {\n        return prevToken;\n      }\n      // access token has expired, try to update\n      return refreshAccessToken(prevToken);\n    },\n    //@ts-ignore can't find exact type problem\n    async session(session, token: Record<string, string>) {\n      logger.info({ session, token }, \"[SESSION_CALLBACK]\");\n\n      if (token) {\n        session.user = { name: token.fullname };\n        session.accessToken = token.access_token;\n        // session.expires = token.expires_in // WATCH !!\n      }\n      return session;\n    },\n  },\n\n  pages: {},\n  events: {\n    async signOut(message) {\n      await revokeJWTTokens(message);\n      logger.info(message, \"[EVENT][SIGN_OUT]\");\n    },\n    async session(message) {\n      logger.info(message, \"[EVENT][SESSION]\");\n    },\n  },\n  debug: true,\n  logger: {\n    error(code, ...message) {\n      logger.error(code, message);\n    },\n    warn(code, ...message) {\n      logger.warn(code, message);\n    },\n    debug(code, ...message) {\n      logger.debug(code, message);\n    },\n  },\n};\n// For more information on each option (and a full list of options) go to\n// https://next-auth.js.org/configuration/options\n\nasync function refreshAccessToken(prevToken: Record<string, any>) {\n  try {\n    logger.warn(prevToken, \"[REFRESH_TOKEN][PREV]\");\n\n    const response = await fetch(ACCESS_TOKEN_URL, {\n      body: new URLSearchParams({\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        grant_type: \"refresh_token\",\n        scope: \"offline_access openid profile\", //TODO:it sould replace with env variable\n        refresh_token: prevToken.refresh_token,\n      }),\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      method: \"POST\",\n    });\n    const responseData = await response.json();\n\n    if (!response.ok) {\n      throw responseData;\n    }\n\n    const { id_token, ...rest } = responseData as JWT_Token;\n\n    const newToken = {\n      ...rest,\n      fullname: prevToken.fullname,\n      expires_in: Date.now() + responseData.expires_in * 1000,\n    };\n\n    logger.warn(newToken, \"[REFRESH_TOKEN][NEW]\");\n\n    return newToken;\n  } catch (error) {\n    logger.error(error, \"[REFRESH_TOKEN]\");\n    return prevToken;\n  }\n}\n\nasync function revokeJWTTokens(token: JWT_Token) {\n  try {\n    await fetch(REVOKE_ACCESS_TOKEN_URL, {\n      headers: {\n        Authorization: token.access_token,\n      },\n      method: \"POST\",\n    }).catch((error) => {\n      throw new Error(error);\n    });\n\n    await fetch(REVOKE_REFRESH_TOKEN_URL, {\n      body: new URLSearchParams({\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        token_type_hint: \"refresh_token\",\n        token: token.refresh_token,\n      }),\n      headers: {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n      },\n      method: \"POST\",\n    }).catch((error) => {\n      throw new Error(error);\n    });\n  } catch (error) {\n    logger.error(error, \"[REVOKE_TOKEN]\");\n  }\n}\n\nexport default (req: NextApiRequest, res: NextApiResponse) =>\n  NextAuth(req, res, options);\n"]},"metadata":{},"sourceType":"module"}